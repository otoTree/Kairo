# 产品需求文档 (PRD): Kairo Agent OS

## 1. 简介 (Introduction)
### 1.1 产品名称
Kairo Agent OS

### 1.2 愿景与背景
Kairo 正从单纯的 LLM Agent 运行时环境演进为一个完全成熟的 **Agent OS（智能体操作系统）**。核心愿景是赋予 Agent 超越文本处理的能力，使其能够：
- **与物理世界交互** (硬件 I/O)。
- **管理系统资源** (进程/内存管理)。
- **通过“智能定义软件”扩展能力** (Skills)。

在这个范式中，Agent 是“一等公民”（类似于传统 OS 中的进程），而“Skills”是由智能编排的动态软件单元。

### 1.3 目标
- **统一内核**: 构建高性能、原生的内核（TypeScript/Rust/C++），核心操作不依赖 MCP。
- **硬件抽象**: 提供标准化、安全的物理硬件访问接口（USB, 串口, GPIO, 摄像头）。
- **技能生态**: 使 Agent 能够部署和控制二进制程序及 AI 模型作为“技能”。
- **深度系统集成**: 利用定制 Linux 能力（PTY, FFI, D-Bus, UDS）实现低延迟、高性能操作。

## 2. 用户故事 (User Stories)
- **作为开发者**，我希望创建包含编译后二进制文件的“技能”，以便我的 Agent 能执行高性能任务（如信号处理）。
- **作为 IoT 集成商**，我希望我的 Agent 能自动检测并配置 USB 设备，这样我就不需要手动映射 `/dev/tty` 路径。
- **作为用户**，我希望给 Agent 授予细粒度的权限（如“访问摄像头”），以便我能保持安全控制。
- **作为 Agent**，我希望启动后台终端来运行长耗时任务，即使用户会话断开也能继续运行。

## 3. 系统架构 (System Architecture)

### 3.1 高层架构
- **用户空间 (User Space)**: Agents, Skills (智能定义软件), 第三方 MCP 工具。
- **Kairo 内核 (Kairo Kernel)**: 编排器, 安全监视器, HAL (硬件抽象层), 全局事件总线。
- **物理硬件 (Physical Hardware)**: USB, 串口/GPIO, 网络, 计算单元。

### 3.2 核心原则
- **内核统一**: 核心功能（进程/内存/驱动）采用原生实现（TS/Rust/C++），使用内部 IPC/共享内存，**而非** MCP。
- **MCP 的定位**: 严格用于**外部**扩展（如 Slack/GitHub 等第三方工具）。不用于内部内核通信。
- **技能即智能定义软件**: Skills 是动态的，可能包含二进制文件或 AI 模型，由 Agent 管理和配置。

## 4. 功能需求 (Functional Requirements)

### 4.1 内核与核心 (Kernel & Core)
| ID | 功能 | 描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| K-01 | **原生内核协议** | 为内核组件实现高性能内部 IPC（绕过 MCP）。 | P0 |
| K-02 | **全局事件总线** | 统一的系统级事件总线（硬件、Agent、用户事件）。 | P0 |
| K-03 | **SystemInfo 模块** | 获取实时系统状态（CPU, 内存, 进程）的原生模块。 | P1 |

### 4.2 硬件抽象层 (HAL)
| ID | 功能 | 描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| H-01 | **设备注册表** | 动态追踪已连接设备（USB, 串口, 摄像头）。 | P1 |
| H-02 | **语义化设备路径** | 基于 VID/PID 自动将设备映射到稳定路径（如 `agent://tty_sensor`）。 | P1 |
| H-03 | **标准接口** | 统一的 API：`serial` (流), `gpio` (I/O), `camera` (帧流)。 | P2 |
| H-04 | **直接硬件访问** | 用于硬件控制的原生绑定 (FFI)，绕过 MCP 以降低延迟。 | P1 |

### 4.3 技能与执行环境 (Skills & Execution Environment)
| ID | 功能 | 描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| S-01 | **二进制技能支持** | 支持打包、校验和执行编译后的二进制文件（ARM64/x64）作为技能。 | P1 |
| S-02 | **高性能 IPC** | 支持 Agent 与二进制文件之间通过 Unix Domain Sockets / 共享内存通信。 | P1 |
| S-03 | **无限终端** | 支持持久化后台 PTY 会话（类似 `tmux`/`screen` 逻辑）。 | P2 |
| S-04 | **原子技能库** | 预置常用 FFI 库（OpenCV, SQLite, FFmpeg）以便即时调用。 | P2 |

### 4.4 安全 (Security)
| ID | 功能 | 描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| SEC-01 | **权限清单** | 技能的声明式权限（例如 `device: serial`）。 | P0 |
| SEC-02 | **用户许可流程** | 针对关键资源访问请求的内核级拦截。 | P0 |
| SEC-03 | **沙盒执行** | 隔离二进制技能以防止系统破坏。 | P1 |

## 5. 非功能需求 (Non-Functional Requirements)
- **延迟**: 通过原生绑定进行的硬件控制循环延迟 < 10ms。
- **稳定性**: 内核必须能在单个 Agent 或 Skill 崩溃时存活。
- **兼容性**: 核心系统面向定制 Linux (Yocto/Buildroot)，但运行时应支持 macOS/Linux 以便开发。

## 6. 路线图 (Roadmap)

### 第一阶段：系统感知与内核基础
- [ ] 定义非 MCP 内核 API 规范。
- [ ] 实现 `SystemInfo` 原生模块。
- [ ] 建立原生 IPC 机制。

### 第二阶段：智能定义软件基础
- [ ] 升级 `Skill` 架构以支持二进制分发。
- [ ] 实现二进制进程的生命周期管理（启动/停止/监控）。
- [ ] 实现用于 Agent 通信的 Unix Domain Socket。

### 第三阶段：硬件接口接管
- [ ] 实现 `DeviceManager` 和设备注册表。
- [ ] 开发串口/GPIO 的原生绑定。
- [ ] 演示：Agent 通过加载二进制技能控制物理设备。

## 7. 待解决问题 / 风险 (Open Questions / Risks)
- **安全模型**: 如何在不阻碍性能的情况下有效地沙盒化二进制技能？
- **驱动兼容性**: 如何管理不同宿主 Linux 版本间的各种硬件驱动？
- **资源限制**: 防止 Agent/Skills 耗尽系统资源（CPU/RAM）。
