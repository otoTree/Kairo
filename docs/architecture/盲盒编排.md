# Agent 驱动 UI 下的敏感信息隔离架构：盲盒编排 (Blind Orchestration)

## 一、 产品需求文档 (PRD)

### 1. 业务背景
在 Agent 驱动的系统中，Agent 负责动态编排 UI 和调用各类 Skill（能力模块）。为了平衡开发效率与安全性，系统提供灵活的安全等级选择，并处理重名 Skill 冲突。同时，必须确保即使 Skill 标识符（UID）被窃取，系统依然具备纵深防御能力。

### 2. 核心目标
*   **Agent 零接触**：核心凭证绝不经过 Agent 逻辑层。
*   **声明式安全**：Skill 可自主选择隔离等级。
*   **UID 窃取防御**：通过多因子身份校验确保 UID 无法被伪造或跨环境冒用。

### 3. 用户场景流程 (User Stories)
*   **身份伪造尝试**：恶意模块窃取了 `ImageOptimizer` 的 UID，并尝试调用 Vault。系统通过校验调用方的进程 ID、Cgroup 和二进制哈希发现不匹配，拒绝访问。
*   **动态令牌更新**：UID 作为静态索引，而实际访问需要宿主环境动态注入的 Ephemeral Secret (临时令牌)。

## 二、 技术规格说明书 (Spec)

### 1. 核心架构组件

#### A. 安全句柄协议 (Secure Handle Protocol)
*   **Handle 类型**：分为 Session Handle 和 Scope Handle。

#### B. 纵深隔离的 UID-Based Vault
*   **唯一性算法**：`Skill_UID = Hash(Developer_Cert + Skill_Name + Version)`。
*   **身份三因子校验 (Identity Attestation)**：
    *   **静态 UID**：标识资源所属分区。
    *   **动态实例令牌 (Runtime Token)**：由宿主环境启动沙箱时动态注入内存。
    *   **内核指纹 (Kernel Fingerprint)**：校验调用方的进程 ID (PID)、父进程、cgroup 及二进制文件的磁盘 Hash。

#### C. 声明式安全清单 (Security Manifest)
*   包含 `manifest.json`，声明安全诉求及开发者指纹。

### 2. 关键接口定义

#### 1. 深度隔离接口 (Vault Client SDK)

```typescript
interface SecurityContext {
  readonly skill_uid: string; 
  // 必须携带由系统注入的临时 Auth Token 才能访问私有仓库
  privateVault: {
    setItem: (key: string, value: Buffer, runtimeToken: string) => Promise<void>;
  };
}
```

#### 2. 系统强制防御钩子 (内核级)

```cpp
// Vault 服务端的校验逻辑
bool verify_request_authenticity(Request req) {
    // 1. 校验 req.uid 是否在合法运行列表中
    // 2. 校验 req.pid 对应的 binary_hash 是否与注册时一致 (通过 /proc/pid/exe)
    // 3. 校验 req.runtimeToken 是否属于该进程实例
    return (db_hash == current_process_hash && valid_token);
}
```

### 3. 运行逻辑 (Sequence)
1.  **注册阶段**：计算 Skill_UID 并记录二进制 Hash。
2.  **加载阶段**：宿主环境启动沙箱，分配唯一 PID。生成 一次性 Runtime Token 注入该进程环境变量。
3.  **执行阶段**：Skill 调用 Vault 时，Vault 侧通过 `getsockopt(SO_PEERCRED)` 或 `/proc` 文件系统获取调用者的内核元数据。即使 UID 泄露，攻击进程也因 Binary Hash 或 Runtime Token 校验失败被拦截。
4.  **销毁阶段**：Runtime Token 失效，清理所有临时授权。

## 三、 安全风险评估 (Security Audit)

| 威胁向量 | 缓解方案 |
| :--- | :--- |
| **Skill 重名覆盖** | 强制使用基于签名的 Skill_UID。 |
| **UID 被窃取/冒用** | 运行时身份验证：校验进程的二进制 Hash 和动态注入的实例令牌。 |
| **自持存储残留** | 宿主驱动的 Hard Wipe。 |
| **Agent 模拟请求** | 校验 cgroup 隔离标识。Agent 进程无法伪造内核层面的进程所属关系。 |

## 四、 结论
通过将静态标识（UID）与动态特征（Runtime Token + Kernel Attestation）结合，系统实现了即便 UID 暴露也无法被外部恶意进程利用的效果。
