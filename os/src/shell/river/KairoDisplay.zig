const std = @import("std");
const wayland = @import("wayland");
const wl = wayland.server.wl;
const wlr = @import("wlroots");
const Server = @import("Server.zig");
const kairo = wayland.server.kairo;

const log = std.log.scoped(.kairo_display);

const KairoDisplay = @This();

global: *wl.Global,
server: *Server,

pub fn init(self: *KairoDisplay) !void {
    self.server = @fieldParentPtr("kairo_display", self);
    self.global = try wl.Global.create(
        self.server.wl_server,
        kairo.DisplayV1,
        1,
        *KairoDisplay,
        self,
        bind,
    );
}

fn bind(client: *wl.Client, self: *KairoDisplay, version: u32, id: u32) void {
    const resource = kairo.DisplayV1.create(client, version, id) catch {
        client.postNoMemory();
        return;
    };
    resource.setHandler(*KairoDisplay, handleRequest, handleDestroy, self);
}

fn handleDestroy(resource: *kairo.DisplayV1, _: *KairoDisplay) void {
    _ = resource;
}

fn handleRequest(
    resource: *kairo.DisplayV1,
    request: kairo.DisplayV1.Request,
    self: *KairoDisplay,
) void {
    switch (request) {
        .get_kairo_surface => |args| {
            createKairoSurface(resource, args.id, args.surface, self);
        },
    }
}

fn createKairoSurface(
    display_resource: *kairo.DisplayV1,
    id: u32,
    surface_resource: *wl.Surface,
    self: *KairoDisplay,
) void {
    const client = display_resource.getClient();
    const allocator = std.heap.c_allocator;

    const kairo_surface = allocator.create(KairoSurface) catch {
        client.postNoMemory();
        return;
    };
    errdefer allocator.destroy(kairo_surface);

    const resource = kairo.SurfaceV1.create(client, 1, id) catch {
        client.postNoMemory();
        return;
    };

    kairo_surface.* = .{
        .server = self.server,
        .surface_resource = surface_resource,
        .resource = resource,
    };

    resource.setHandler(*KairoSurface, KairoSurface.handleRequest, KairoSurface.handleDestroy, kairo_surface);
}

// ============================================================
// KairoSurface: 接收 JSON UI 树并渲染到 overlay 层
// ============================================================

const KairoSurface = struct {
    server: *Server,
    surface_resource: *wl.Surface,
    resource: *kairo.SurfaceV1,
    /// overlay 子树，用于管理所有渲染节点的生命周期
    overlay_tree: ?*wlr.SceneTree = null,

    fn handleDestroy(resource: *kairo.SurfaceV1, self: *KairoSurface) void {
        _ = resource;
        // 销毁 overlay 子树（自动销毁所有子节点）
        if (self.overlay_tree) |tree| {
            tree.node.destroy();
        }
        std.heap.c_allocator.destroy(self);
    }

    fn handleRequest(
        resource: *kairo.SurfaceV1,
        request: kairo.SurfaceV1.Request,
        self: *KairoSurface,
    ) void {
        switch (request) {
            .commit_ui_tree => |args| {
                const payload = std.mem.span(args.json_payload);
                log.info("KDP: Received UI Tree: {s}", .{payload});
                self.renderUITree(payload);
            },
            .destroy => {
                resource.destroy();
            },
        }
    }

    /// 解析 JSON UI 树并渲染到 overlay 场景层
    fn renderUITree(self: *KairoSurface, json_payload: [:0]const u8) void {
        // 清理旧的 overlay 节点
        if (self.overlay_tree) |tree| {
            tree.node.destroy();
            self.overlay_tree = null;
        }

        // 在 overlay 层创建新的子树
        const overlay_parent = self.server.scene.layers.overlay;
        const tree = overlay_parent.createSceneTree() catch {
            log.err("KDP: 无法创建 overlay 子树", .{});
            return;
        };
        self.overlay_tree = tree;

        // 解析 JSON
        const parsed = std.json.parseFromSlice(UIElement, std.heap.c_allocator, json_payload, .{
            .ignore_unknown_fields = true,
        }) catch |err| {
            log.err("KDP: JSON 解析失败: {}", .{err});
            return;
        };
        defer parsed.deinit();

        // 递归渲染 UI 元素
        renderElement(tree, &parsed.value);
        log.info("KDP: UI 树渲染完成", .{});
    }
};

// ============================================================
// UI 元素定义与渲染
// ============================================================

const UIElement = struct {
    @"type": []const u8 = "",
    x: ?i32 = null,
    y: ?i32 = null,
    width: ?i32 = null,
    height: ?i32 = null,
    color: ?[4]f32 = null,
    text: ?[]const u8 = null,
    scale: ?i32 = null,
    children: ?[]const UIElement = null,
};

/// 递归渲染 UI 元素到场景树
fn renderElement(parent: *wlr.SceneTree, element: *const UIElement) void {
    const elem_type = element.@"type";

    if (std.mem.eql(u8, elem_type, "rect")) {
        renderRect(parent, element);
    } else if (std.mem.eql(u8, elem_type, "text")) {
        renderText(parent, element);
    }

    // 递归渲染子元素
    if (element.children) |children| {
        for (children) |*child| {
            renderElement(parent, child);
        }
    }
}

/// 渲染矩形元素
fn renderRect(parent: *wlr.SceneTree, element: *const UIElement) void {
    const w: c_int = @intCast(element.width orelse 100);
    const h: c_int = @intCast(element.height orelse 40);
    const color = element.color orelse [4]f32{ 0.2, 0.2, 0.3, 0.9 };

    const rect = parent.createSceneRect(w, h, &color) catch {
        log.err("KDP: 无法创建矩形节点", .{});
        return;
    };
    rect.node.setPosition(element.x orelse 0, element.y orelse 0);
}

/// 渲染文本元素（使用内嵌 8x8 位图字体）
fn renderText(parent: *wlr.SceneTree, element: *const UIElement) void {
    const text = element.text orelse return;
    const scale: u31 = @intCast(element.scale orelse 2);
    const color = element.color orelse [4]f32{ 1.0, 1.0, 1.0, 1.0 };
    const base_x = element.x orelse 0;
    const base_y = element.y orelse 0;

    // 为文本创建子树，方便统一定位
    const text_tree = parent.createSceneTree() catch return;
    text_tree.node.setPosition(base_x, base_y);

    var cursor_x: c_int = 0;
    for (text) |ch| {
        if (ch < 32 or ch > 126) {
            cursor_x += 8 * @as(c_int, scale);
            continue;
        }
        const glyph = font_8x8[ch - 32];
        renderGlyph(text_tree, glyph, cursor_x, 0, scale, &color);
        cursor_x += 8 * @as(c_int, scale);
    }
}

/// 渲染单个字符的位图
fn renderGlyph(
    parent: *wlr.SceneTree,
    glyph: [8]u8,
    ox: c_int,
    oy: c_int,
    scale: u31,
    color: *const [4]f32,
) void {
    // 逐行扫描位图，合并连续像素为水平条带以减少节点数
    for (glyph, 0..) |row, yi| {
        var x: u32 = 0;
        while (x < 8) {
            if (row & (@as(u8, 0x80) >> @as(u3, @intCast(x))) != 0) {
                // 找到连续的 "on" 像素
                const start_x = x;
                while (x < 8 and (row & (@as(u8, 0x80) >> @as(u3, @intCast(x))) != 0)) {
                    x += 1;
                }
                const run_len: c_int = @intCast(x - start_x);
                const px: c_int = ox + @as(c_int, @intCast(start_x)) * @as(c_int, scale);
                const py: c_int = oy + @as(c_int, @intCast(yi)) * @as(c_int, scale);
                const pw: c_int = run_len * @as(c_int, scale);
                const ph: c_int = scale;

                const rect = parent.createSceneRect(pw, ph, color) catch continue;
                rect.node.setPosition(px, py);
            } else {
                x += 1;
            }
        }
    }
}

// ============================================================
// 8x8 位图字体数据 (ASCII 32-126, 共 95 个字符)
// 每个字符 8 行，每行 8 位，最高位为最左像素
// ============================================================

const font_8x8: [95][8]u8 = .{
    // 32: Space
    .{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    // 33: !
    .{ 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00 },
    // 34: "
    .{ 0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 },
    // 35: #
    .{ 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00, 0x00 },
    // 36: $
    .{ 0x18, 0x3E, 0x58, 0x3C, 0x1A, 0x7C, 0x18, 0x00 },
    // 37: %
    .{ 0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00, 0x00 },
    // 38: &
    .{ 0x30, 0x48, 0x30, 0x56, 0x48, 0x34, 0x00, 0x00 },
    // 39: '
    .{ 0x18, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 },
    // 40: (
    .{ 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00 },
    // 41: )
    .{ 0x20, 0x10, 0x08, 0x08, 0x08, 0x10, 0x20, 0x00 },
    // 42: *
    .{ 0x00, 0x24, 0x18, 0x7E, 0x18, 0x24, 0x00, 0x00 },
    // 43: +
    .{ 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00 },
    // 44: ,
    .{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x10 },
    // 45: -
    .{ 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00 },
    // 46: .
    .{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00 },
    // 47: /
    .{ 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00 },
    // 48: 0
    .{ 0x3C, 0x46, 0x4A, 0x52, 0x62, 0x3C, 0x00, 0x00 },
    // 49: 1
    .{ 0x18, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00 },
    // 50: 2
    .{ 0x3C, 0x42, 0x02, 0x1C, 0x20, 0x7E, 0x00, 0x00 },
    // 51: 3
    .{ 0x3C, 0x42, 0x0C, 0x02, 0x42, 0x3C, 0x00, 0x00 },
    // 52: 4
    .{ 0x0C, 0x14, 0x24, 0x7E, 0x04, 0x04, 0x00, 0x00 },
    // 53: 5
    .{ 0x7E, 0x40, 0x7C, 0x02, 0x42, 0x3C, 0x00, 0x00 },
    // 54: 6
    .{ 0x1C, 0x20, 0x7C, 0x42, 0x42, 0x3C, 0x00, 0x00 },
    // 55: 7
    .{ 0x7E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00, 0x00 },
    // 56: 8
    .{ 0x3C, 0x42, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00 },
    // 57: 9
    .{ 0x3C, 0x42, 0x3E, 0x02, 0x04, 0x38, 0x00, 0x00 },
    // 58: :
    .{ 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00 },
    // 59: ;
    .{ 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x10, 0x00 },
    // 60: <
    .{ 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00 },
    // 61: =
    .{ 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00 },
    // 62: >
    .{ 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00 },
    // 63: ?
    .{ 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00, 0x00 },
    // 64: @
    .{ 0x3C, 0x42, 0x5E, 0x56, 0x5E, 0x40, 0x3C, 0x00 },
    // 65: A
    .{ 0x18, 0x24, 0x42, 0x7E, 0x42, 0x42, 0x00, 0x00 },
    // 66: B
    .{ 0x7C, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x00, 0x00 },
    // 67: C
    .{ 0x3C, 0x42, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00 },
    // 68: D
    .{ 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00 },
    // 69: E
    .{ 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x00, 0x00 },
    // 70: F
    .{ 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x00, 0x00 },
    // 71: G
    .{ 0x3C, 0x42, 0x40, 0x4E, 0x42, 0x3C, 0x00, 0x00 },
    // 72: H
    .{ 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00, 0x00 },
    // 73: I
    .{ 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00 },
    // 74: J
    .{ 0x1E, 0x04, 0x04, 0x04, 0x44, 0x38, 0x00, 0x00 },
    // 75: K
    .{ 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00 },
    // 76: L
    .{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00 },
    // 77: M
    .{ 0x42, 0x66, 0x5A, 0x42, 0x42, 0x42, 0x00, 0x00 },
    // 78: N
    .{ 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00, 0x00 },
    // 79: O
    .{ 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00 },
    // 80: P
    .{ 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x00, 0x00 },
    // 81: Q
    .{ 0x3C, 0x42, 0x42, 0x4A, 0x44, 0x3A, 0x00, 0x00 },
    // 82: R
    .{ 0x7C, 0x42, 0x42, 0x7C, 0x44, 0x42, 0x00, 0x00 },
    // 83: S
    .{ 0x3C, 0x40, 0x3C, 0x02, 0x42, 0x3C, 0x00, 0x00 },
    // 84: T
    .{ 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00 },
    // 85: U
    .{ 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00 },
    // 86: V
    .{ 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x00, 0x00 },
    // 87: W
    .{ 0x42, 0x42, 0x42, 0x5A, 0x66, 0x42, 0x00, 0x00 },
    // 88: X
    .{ 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00 },
    // 89: Y
    .{ 0x42, 0x24, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00 },
    // 90: Z
    .{ 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00, 0x00 },
    // 91: [
    .{ 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00 },
    // 92: backslash
    .{ 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00 },
    // 93: ]
    .{ 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x00 },
    // 94: ^
    .{ 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00 },
    // 95: _
    .{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00 },
    // 96: `
    .{ 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },
    // 97: a
    .{ 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x3E, 0x00 },
    // 98: b
    .{ 0x40, 0x40, 0x5C, 0x62, 0x42, 0x62, 0x5C, 0x00 },
    // 99: c
    .{ 0x00, 0x00, 0x3C, 0x42, 0x40, 0x42, 0x3C, 0x00 },
    // 100: d
    .{ 0x02, 0x02, 0x3A, 0x46, 0x42, 0x46, 0x3A, 0x00 },
    // 101: e
    .{ 0x00, 0x00, 0x3C, 0x42, 0x7E, 0x40, 0x3C, 0x00 },
    // 102: f
    .{ 0x0C, 0x12, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x00 },
    // 103: g
    .{ 0x00, 0x00, 0x3A, 0x46, 0x46, 0x3A, 0x02, 0x3C },
    // 104: h
    .{ 0x40, 0x40, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x00 },
    // 105: i
    .{ 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00 },
    // 106: j
    .{ 0x04, 0x00, 0x04, 0x04, 0x04, 0x44, 0x38, 0x00 },
    // 107: k
    .{ 0x40, 0x40, 0x44, 0x48, 0x70, 0x48, 0x44, 0x00 },
    // 108: l
    .{ 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00 },
    // 109: m
    .{ 0x00, 0x00, 0x76, 0x49, 0x49, 0x49, 0x49, 0x00 },
    // 110: n
    .{ 0x00, 0x00, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x00 },
    // 111: o
    .{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x00 },
    // 112: p
    .{ 0x00, 0x00, 0x5C, 0x62, 0x62, 0x5C, 0x40, 0x40 },
    // 113: q
    .{ 0x00, 0x00, 0x3A, 0x46, 0x46, 0x3A, 0x02, 0x02 },
    // 114: r
    .{ 0x00, 0x00, 0x5C, 0x62, 0x40, 0x40, 0x40, 0x00 },
    // 115: s
    .{ 0x00, 0x00, 0x3E, 0x40, 0x3C, 0x02, 0x7C, 0x00 },
    // 116: t
    .{ 0x10, 0x10, 0x3C, 0x10, 0x10, 0x12, 0x0C, 0x00 },
    // 117: u
    .{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00 },
    // 118: v
    .{ 0x00, 0x00, 0x42, 0x42, 0x24, 0x24, 0x18, 0x00 },
    // 119: w
    .{ 0x00, 0x00, 0x41, 0x49, 0x49, 0x49, 0x36, 0x00 },
    // 120: x
    .{ 0x00, 0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00 },
    // 121: y
    .{ 0x00, 0x00, 0x42, 0x42, 0x46, 0x3A, 0x02, 0x3C },
    // 122: z
    .{ 0x00, 0x00, 0x7E, 0x04, 0x18, 0x20, 0x7E, 0x00 },
    // 123: {
    .{ 0x0C, 0x10, 0x10, 0x20, 0x10, 0x10, 0x0C, 0x00 },
    // 124: |
    .{ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00 },
    // 125: }
    .{ 0x30, 0x08, 0x08, 0x04, 0x08, 0x08, 0x30, 0x00 },
    // 126: ~
    .{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00 },
};
