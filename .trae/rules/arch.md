# **通用项目架构指南 (Universal Project Architecture Guidelines)**

## **1. 垂直领域切片 (Vertical Domain Slicing)**
*   **核心理念**：按“业务领域”而非“技术层级”组织代码。
*   **实践准则**：
    *   禁止将所有 Service、Controller、Type 分别堆放在全局文件夹中。
    *   每个功能模块（如 `payment`, `auth`, `notification`）应拥有独立的文件夹。
    *   该文件夹内应包含该功能所需的一切：逻辑代码、私有工具函数、私有类型定义、以及测试用例。
*   **收益**：极低的心智负担，开发者只需关注当前工作的领域目录。

## **2. 微内核与插件化设计 (Microkernel & Plugin Architecture)**
*   **核心理念**：保持核心（Core）精简，通过插件（Plugins/Extensions）实现功能蔓延。
*   **实践准则**：
    *   核心层仅定义“生命周期”、“调度逻辑”和“标准接口”。
    *   任何非通用的、第三方的、或者易变的逻辑，必须以插件形式存在。
    *   插件通过统一的 `API` 对象向核心注册自己的能力，而不是核心去显式引用插件。
*   **收益**：系统具备极强的可扩展性，且核心逻辑保持高度稳定。

## **3. 协议驱动的解耦 (Protocol-Driven Decoupling)**
*   **核心理念**：模块间不直接通信，而是通过“标准协议”或“中介者”交互。
*   **实践准则**：
    *   定义一套内部 RPC 或事件协议（如项目中的 ACP 协议）。
    *   跨模块调用时，优先使用事件订阅或标准接口调用，严禁跨领域直接实例化对方的内部类。
    *   如果两个模块耦合过紧，应考虑将其共同部分提取到 `shared` 基础层，或重新定义它们之间的通信协议。
*   **收益**：模块可独立替换，甚至可以轻松地从单体架构迁移到微服务架构。

## **4. 元数据与 Schema 驱动 (Schema-Driven Development)**
*   **核心理念**：将逻辑与配置分离，用 Schema 定义配置。
*   **实践准则**：
    *   所有外部输入和配置项必须配套 JSON Schema 或 Protobuf 定义。
    *   利用 Schema 在运行时进行自动校验，并以此驱动 UI 渲染（如自动生成配置界面）。
    *   配置变更应能被系统感知，并触发相应的生命周期回调。
*   **收益**：减少防御性代码，提高系统的自描述能力和安全性。

## **5. 基础设施依赖注入 (Inversion of Control for Infra)**
*   **核心理念**：模块“使用”资源，但不“寻找”或“创建”资源。
*   **实践准则**：
    *   底层基础设施（数据库、缓存、日志、文件系统）应在应用启动时统一初始化。
    *   通过依赖注入（DI）或 Context 对象将这些实例传递给业务模块。
    *   业务模块内部不应出现具体的环境配置（如硬编码的数据库连接字符串）。
*   **收益**：极高的可测试性，可以轻松通过 Mock 实例进行单元测试。

## **6. 物理相邻原则 (The Co-location Principle)**
*   **核心理念**：将变化频率相同的东西放在一起。
*   **实践准则**：
    *   **测试相邻**：`xxx.test.ts` 必须放在 `xxx.ts` 旁边。
    *   **文档相邻**：模块的 README 或说明文件应放在该模块目录下。
    *   **类型相邻**：仅在该模块使用的类型定义应放在模块内的 `types.ts`。
*   **收益**：重构时不会遗漏测试，移动文件夹时能带走所有依赖，维护成本最低。

## **7. 极薄的交互层 (Thin Interaction Layer)**
*   **核心理念**：UI、CLI 或 API 只是业务逻辑的“皮肤”。
*   **实践准则**：
    *   交互层（如 `src/cli` 或 `src/routes`）应保持极薄，仅负责参数解析、权限校验和调用核心逻辑。
    *   真正的业务决策必须封装在领域模块中，确保同一套逻辑可以被 CLI、REST API、WebSocket 等多种方式复用。
*   **收益**：业务逻辑平台无关，方便适配各种交互终端。