# **通用项目架构指南 (Universal Project Architecture Guidelines)**

## **1. 垂直领域切片 (Vertical Domain Slicing)**
*   **核心理念**：按“业务领域”而非“技术层级”组织代码。
*   **实践准则**：
    *   禁止将所有 Service、Controller、Type 分别堆放在全局文件夹中。
    *   每个功能模块（如 `payment`, `auth`, `notification`）应拥有独立的文件夹。
    *   该文件夹内应包含该功能所需的一切：逻辑代码、私有工具函数、私有类型定义、以及测试用例。
*   **收益**：极低的心智负担，开发者只需关注当前工作的领域目录。

## **2. 微内核与插件化设计 (Microkernel & Plugin Architecture)**
*   **核心理念**：保持核心（Core）精简，通过插件（Plugins/Extensions）实现功能蔓延。
*   **实践准则**：
    *   核心层仅定义“生命周期”、“调度逻辑”和“标准接口”。
    *   任何非通用的、第三方的、或者易变的逻辑，必须以插件形式存在。
    *   插件通过统一的 `API` 对象向核心注册自己的能力，而不是核心去显式引用插件。
*   **收益**：系统具备极强的可扩展性，且核心逻辑保持高度稳定。

## **3. 协议驱动的解耦 (Protocol-Driven Decoupling)**
*   **核心理念**：模块间不直接通信，而是通过“标准协议”或“中介者”交互。
*   **实践准则**：
    *   定义一套内部 RPC 或事件协议（如项目中的 ACP 协议）。
    *   跨模块调用时，优先使用事件订阅或标准接口调用，严禁跨领域直接实例化对方的内部类。
    *   如果两个模块耦合过紧，应考虑将其共同部分提取到 `shared` 基础层，或重新定义它们之间的通信协议。
*   **收益**：模块可独立替换，甚至可以轻松地从单体架构迁移到微服务架构。

## **4. 元数据与 Schema 驱动 (Schema-Driven Development)**
*   **核心理念**：将逻辑与配置分离，用 Schema 定义配置。
*   **实践准则**：
    *   所有外部输入和配置项必须配套 JSON Schema 或 Protobuf 定义。
    *   利用 Schema 在运行时进行自动校验，并以此驱动 UI 渲染（如自动生成配置界面）。
    *   配置变更应能被系统感知，并触发相应的生命周期回调。
*   **收益**：减少防御性代码，提高系统的自描述能力和安全性。

## **5. 基础设施依赖注入 (Inversion of Control for Infra)**
*   **核心理念**：模块“使用”资源，但不“寻找”或“创建”资源。
*   **实践准则**：
    *   底层基础设施（数据库、缓存、日志、文件系统）应在应用启动时统一初始化。
    *   通过依赖注入（DI）或 Context 对象将这些实例传递给业务模块。
    *   业务模块内部不应出现具体的环境配置（如硬编码的数据库连接字符串）。
*   **收益**：极高的可测试性，可以轻松通过 Mock 实例进行单元测试。

## **6. 物理相邻原则 (The Co-location Principle)**
*   **核心理念**：将变化频率相同的东西放在一起。
*   **实践准则**：
    *   **测试相邻**：`xxx.test.ts` 必须放在 `xxx.ts` 旁边。
    *   **文档相邻**：模块的 README 或说明文件应放在该模块目录下。
    *   **类型相邻**：仅在该模块使用的类型定义应放在模块内的 `types.ts`。
*   **收益**：重构时不会遗漏测试，移动文件夹时能带走所有依赖，维护成本最低。

## **7. 极薄的交互层 (Thin Interaction Layer)**
*   **核心理念**：UI、CLI 或 API 只是业务逻辑的“皮肤”。
*   **实践准则**：
    *   交互层（如 `src/cli` 或 `src/routes`）应保持极薄，仅负责参数解析、权限校验和调用核心逻辑。
    *   真正的业务决策必须封装在领域模块中，确保同一套逻辑可以被 CLI、REST API、WebSocket 等多种方式复用。
*   **收益**：业务逻辑平台无关，方便适配各种交互终端。

# 开发阅读规则

本规则适用于阅读 /Users/hjr/Desktop/Kairo/docs 目录下的文档。目标是建立一致的阅读顺序、记录方式和输出标准，确保所有成员理解一致。

## 一、阅读范围

- 仅聚焦 docs 目录内的内容
- 不扩展到实现代码、外部资料或历史版本记录

## 二、阅读顺序

1. 顶层产品与愿景：agent_os_vision.md、prd_agent_os.md、prd_agent_os_zh.md
2. 体系结构与总览：architecture/ 目录内的系统架构与运行时相关文档
3. MVP 体系：mvp/README.md 然后按 01～07 顺序阅读
4. 版本规划：version/ 按 v0.1 到 v1.0 顺序阅读
5. 专题规范与补充：local-database-spec.md、skill-integration-spec.md、stateful-agent-hz.md、linux_customization_plan.md

## 三、阅读方法

- 每次阅读只关注一个主题，不交叉跳读
- 先理解目标与术语，再理解流程、模块与接口
- 对出现的名词、协议、组件形成一致的心智模型
- 阅读中禁止引入个人实现假设，均以文档为准

## 四、记录要求

- 记录必须结构化，建议格式为：目标、核心概念、关键流程、依赖关系、待澄清点
- 关键结论需与文档位置绑定，引用文件名和标题
- 如果发现冲突或版本差异，记录为待澄清点，不擅自裁定

## 五、输出标准

- 输出内容需覆盖当前阅读文档的核心目标和约束
- 输出必须区分事实与推断，推断需标注依据
- 输出必须可复用，避免个人化表达

## 六、禁止项

- 禁止跳过目录层级直接阅读细节文档
- 禁止仅凭经验补全文档缺失内容
- 禁止以个人设计替代文档约束

